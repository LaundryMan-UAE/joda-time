//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/andrewebling/Laundrapp/Joda-time-Project/joda-time/src/main/java/org/joda/time/base/AbstractInterval.java
//

#include "AbstractInterval.h"
#include "Chronology.h"
#include "DateTime.h"
#include "DateTimeFormatter.h"
#include "DateTimeUtils.h"
#include "Duration.h"
#include "FieldUtils.h"
#include "ISODateTimeFormat.h"
#include "Interval.h"
#include "MutableInterval.h"
#include "Period.h"
#include "PeriodType.h"
#include "ReadableInstant.h"
#include "ReadableInterval.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/StringBuffer.h"

@implementation OrgJodaTimeBaseAbstractInterval

- (instancetype)init {
  return [super init];
}

- (void)checkIntervalWithLong:(long long int)start
                     withLong:(long long int)end {
  if (end < start) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"The end instant must be greater or equal to the start"];
  }
}

- (OrgJodaTimeDateTime *)getStart {
  return [[OrgJodaTimeDateTime alloc] initWithLong:[self getStartMillis] withOrgJodaTimeChronology:[self getChronology]];
}

- (OrgJodaTimeDateTime *)getEnd {
  return [[OrgJodaTimeDateTime alloc] initWithLong:[self getEndMillis] withOrgJodaTimeChronology:[self getChronology]];
}

- (BOOL)containsWithLong:(long long int)millisInstant {
  long long int thisStart = [self getStartMillis];
  long long int thisEnd = [self getEndMillis];
  return (millisInstant >= thisStart && millisInstant < thisEnd);
}

- (BOOL)containsNow {
  return [self containsWithLong:[OrgJodaTimeDateTimeUtils currentTimeMillis]];
}

- (BOOL)containsWithOrgJodaTimeReadableInstant:(id<OrgJodaTimeReadableInstant>)instant {
  if (instant == nil) {
    return [self containsNow];
  }
  return [self containsWithLong:[((id<OrgJodaTimeReadableInstant>) nil_chk(instant)) getMillis]];
}

- (BOOL)containsWithOrgJodaTimeReadableInterval:(id<OrgJodaTimeReadableInterval>)interval {
  if (interval == nil) {
    return [self containsNow];
  }
  long long int otherStart = [((id<OrgJodaTimeReadableInterval>) nil_chk(interval)) getStartMillis];
  long long int otherEnd = [interval getEndMillis];
  long long int thisStart = [self getStartMillis];
  long long int thisEnd = [self getEndMillis];
  return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd);
}

- (BOOL)overlapsWithOrgJodaTimeReadableInterval:(id<OrgJodaTimeReadableInterval>)interval {
  long long int thisStart = [self getStartMillis];
  long long int thisEnd = [self getEndMillis];
  if (interval == nil) {
    long long int now = [OrgJodaTimeDateTimeUtils currentTimeMillis];
    return (thisStart < now && now < thisEnd);
  }
  else {
    long long int otherStart = [interval getStartMillis];
    long long int otherEnd = [interval getEndMillis];
    return (thisStart < otherEnd && otherStart < thisEnd);
  }
}

- (BOOL)isEqualWithOrgJodaTimeReadableInterval:(id<OrgJodaTimeReadableInterval>)other {
  return [self getStartMillis] == [((id<OrgJodaTimeReadableInterval>) nil_chk(other)) getStartMillis] && [self getEndMillis] == [other getEndMillis];
}

- (BOOL)isBeforeWithLong:(long long int)millisInstant {
  return ([self getEndMillis] <= millisInstant);
}

- (BOOL)isBeforeNow {
  return [self isBeforeWithLong:[OrgJodaTimeDateTimeUtils currentTimeMillis]];
}

- (BOOL)isBeforeWithOrgJodaTimeReadableInstant:(id<OrgJodaTimeReadableInstant>)instant {
  if (instant == nil) {
    return [self isBeforeNow];
  }
  return [self isBeforeWithLong:[((id<OrgJodaTimeReadableInstant>) nil_chk(instant)) getMillis]];
}

- (BOOL)isBeforeWithOrgJodaTimeReadableInterval:(id<OrgJodaTimeReadableInterval>)interval {
  if (interval == nil) {
    return [self isBeforeNow];
  }
  return [self isBeforeWithLong:[((id<OrgJodaTimeReadableInterval>) nil_chk(interval)) getStartMillis]];
}

- (BOOL)isAfterWithLong:(long long int)millisInstant {
  return ([self getStartMillis] > millisInstant);
}

- (BOOL)isAfterNow {
  return [self isAfterWithLong:[OrgJodaTimeDateTimeUtils currentTimeMillis]];
}

- (BOOL)isAfterWithOrgJodaTimeReadableInstant:(id<OrgJodaTimeReadableInstant>)instant {
  if (instant == nil) {
    return [self isAfterNow];
  }
  return [self isAfterWithLong:[((id<OrgJodaTimeReadableInstant>) nil_chk(instant)) getMillis]];
}

- (BOOL)isAfterWithOrgJodaTimeReadableInterval:(id<OrgJodaTimeReadableInterval>)interval {
  long long int endMillis;
  if (interval == nil) {
    endMillis = [OrgJodaTimeDateTimeUtils currentTimeMillis];
  }
  else {
    endMillis = [interval getEndMillis];
  }
  return ([self getStartMillis] >= endMillis);
}

- (OrgJodaTimeInterval *)toInterval {
  return [[OrgJodaTimeInterval alloc] initWithLong:[self getStartMillis] withLong:[self getEndMillis] withOrgJodaTimeChronology:[self getChronology]];
}

- (OrgJodaTimeMutableInterval *)toMutableInterval {
  return [[OrgJodaTimeMutableInterval alloc] initWithLong:[self getStartMillis] withLong:[self getEndMillis] withOrgJodaTimeChronology:[self getChronology]];
}

- (long long int)toDurationMillis {
  return [OrgJodaTimeFieldFieldUtils safeAddWithLong:[self getEndMillis] withLong:-[self getStartMillis]];
}

- (OrgJodaTimeDuration *)toDuration {
  long long int durMillis = [self toDurationMillis];
  if (durMillis == 0) {
    return OrgJodaTimeDuration_get_ZERO_();
  }
  else {
    return [[OrgJodaTimeDuration alloc] initWithLong:durMillis];
  }
}

- (OrgJodaTimePeriod *)toPeriod {
  return [[OrgJodaTimePeriod alloc] initWithLong:[self getStartMillis] withLong:[self getEndMillis] withOrgJodaTimeChronology:[self getChronology]];
}

- (OrgJodaTimePeriod *)toPeriodWithOrgJodaTimePeriodType:(OrgJodaTimePeriodType *)type {
  return [[OrgJodaTimePeriod alloc] initWithLong:[self getStartMillis] withLong:[self getEndMillis] withOrgJodaTimePeriodType:type withOrgJodaTimeChronology:[self getChronology]];
}

- (BOOL)isEqual:(id)readableInterval {
  if (self == readableInterval) {
    return YES;
  }
  if ([readableInterval conformsToProtocol: @protocol(OrgJodaTimeReadableInterval)] == NO) {
    return NO;
  }
  id<OrgJodaTimeReadableInterval> other = (id<OrgJodaTimeReadableInterval>) check_protocol_cast(readableInterval, @protocol(OrgJodaTimeReadableInterval));
  return [self getStartMillis] == [((id<OrgJodaTimeReadableInterval>) nil_chk(other)) getStartMillis] && [self getEndMillis] == [other getEndMillis] && [OrgJodaTimeFieldFieldUtils equalsWithId:[self getChronology] withId:[other getChronology]];
}

- (NSUInteger)hash {
  long long int start = [self getStartMillis];
  long long int end = [self getEndMillis];
  int result = 97;
  result = 31 * result + ((int) (start ^ ((long long) (((unsigned long long) start) >> 32))));
  result = 31 * result + ((int) (end ^ ((long long) (((unsigned long long) end) >> 32))));
  result = 31 * result + ((int) [((OrgJodaTimeChronology *) nil_chk([self getChronology])) hash]);
  return result;
}

- (NSString *)description {
  OrgJodaTimeFormatDateTimeFormatter *printer = [OrgJodaTimeFormatISODateTimeFormat dateTime];
  printer = [((OrgJodaTimeFormatDateTimeFormatter *) nil_chk(printer)) withChronologyWithOrgJodaTimeChronology:[self getChronology]];
  JavaLangStringBuffer *buf = [[JavaLangStringBuffer alloc] initWithInt:48];
  [((OrgJodaTimeFormatDateTimeFormatter *) nil_chk(printer)) printToWithJavaLangStringBuffer:buf withLong:[self getStartMillis]];
  (void) [buf appendWithChar:'/'];
  [printer printToWithJavaLangStringBuffer:buf withLong:[self getEndMillis]];
  return [buf description];
}

- (OrgJodaTimeChronology *)getChronology {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (long long int)getEndMillis {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (long long int)getStartMillis {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "init", "AbstractInterval", NULL, 0x4, NULL },
    { "checkIntervalWithLong:withLong:", "checkInterval", "V", 0x4, NULL },
    { "getStart", NULL, "Lorg.joda.time.DateTime;", 0x1, NULL },
    { "getEnd", NULL, "Lorg.joda.time.DateTime;", 0x1, NULL },
    { "containsWithLong:", "contains", "Z", 0x1, NULL },
    { "containsNow", NULL, "Z", 0x1, NULL },
    { "containsWithOrgJodaTimeReadableInstant:", "contains", "Z", 0x1, NULL },
    { "containsWithOrgJodaTimeReadableInterval:", "contains", "Z", 0x1, NULL },
    { "overlapsWithOrgJodaTimeReadableInterval:", "overlaps", "Z", 0x1, NULL },
    { "isEqualWithOrgJodaTimeReadableInterval:", "isEqual", "Z", 0x1, NULL },
    { "isBeforeWithLong:", "isBefore", "Z", 0x1, NULL },
    { "isBeforeNow", NULL, "Z", 0x1, NULL },
    { "isBeforeWithOrgJodaTimeReadableInstant:", "isBefore", "Z", 0x1, NULL },
    { "isBeforeWithOrgJodaTimeReadableInterval:", "isBefore", "Z", 0x1, NULL },
    { "isAfterWithLong:", "isAfter", "Z", 0x1, NULL },
    { "isAfterNow", NULL, "Z", 0x1, NULL },
    { "isAfterWithOrgJodaTimeReadableInstant:", "isAfter", "Z", 0x1, NULL },
    { "isAfterWithOrgJodaTimeReadableInterval:", "isAfter", "Z", 0x1, NULL },
    { "toInterval", NULL, "Lorg.joda.time.Interval;", 0x1, NULL },
    { "toMutableInterval", NULL, "Lorg.joda.time.MutableInterval;", 0x1, NULL },
    { "toDurationMillis", NULL, "J", 0x1, NULL },
    { "toDuration", NULL, "Lorg.joda.time.Duration;", 0x1, NULL },
    { "toPeriod", NULL, "Lorg.joda.time.Period;", 0x1, NULL },
    { "toPeriodWithOrgJodaTimePeriodType:", "toPeriod", "Lorg.joda.time.Period;", 0x1, NULL },
    { "isEqual:", "equals", "Z", 0x1, NULL },
    { "hash", "hashCode", "I", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
    { "getChronology", NULL, "Lorg.joda.time.Chronology;", 0x401, NULL },
    { "getEndMillis", NULL, "J", 0x401, NULL },
    { "getStartMillis", NULL, "J", 0x401, NULL },
  };
  static J2ObjcClassInfo _OrgJodaTimeBaseAbstractInterval = { "AbstractInterval", "org.joda.time.base", NULL, 0x401, 30, methods, 0, NULL, 0, NULL};
  return &_OrgJodaTimeBaseAbstractInterval;
}

@end
