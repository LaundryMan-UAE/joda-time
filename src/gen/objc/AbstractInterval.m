//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/nbransby/Documents/joda-time/src/main/java/org/joda/time/base/AbstractInterval.java
//

#include "AbstractInterval.h"
#include "Chronology.h"
#include "DateTime.h"
#include "DateTimeFormatter.h"
#include "DateTimeUtils.h"
#include "Duration.h"
#include "FieldUtils.h"
#include "ISODateTimeFormat.h"
#include "Interval.h"
#include "MutableInterval.h"
#include "Period.h"
#include "PeriodType.h"
#include "ReadableInstant.h"
#include "ReadableInterval.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/StringBuffer.h"

#pragma clang diagnostic ignored "-Wprotocol"

@implementation OrgJodaTimeBaseAbstractInterval

- (instancetype)init {
  return [super init];
}

- (void)checkIntervalWithLong:(jlong)start
                     withLong:(jlong)end {
  if (end < start) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"The end instant must be greater or equal to the start"] autorelease];
  }
}

- (OrgJodaTimeDateTime *)getStart {
  return [[[OrgJodaTimeDateTime alloc] initWithLong:[self getStartMillis] withOrgJodaTimeChronology:[self getChronology]] autorelease];
}

- (OrgJodaTimeDateTime *)getEnd {
  return [[[OrgJodaTimeDateTime alloc] initWithLong:[self getEndMillis] withOrgJodaTimeChronology:[self getChronology]] autorelease];
}

- (jboolean)containsWithLong:(jlong)millisInstant {
  jlong thisStart = [self getStartMillis];
  jlong thisEnd = [self getEndMillis];
  return (millisInstant >= thisStart && millisInstant < thisEnd);
}

- (jboolean)containsNow {
  return [self containsWithLong:OrgJodaTimeDateTimeUtils_currentTimeMillis()];
}

- (jboolean)containsWithOrgJodaTimeReadableInstant:(id<OrgJodaTimeReadableInstant>)instant {
  if (instant == nil) {
    return [self containsNow];
  }
  return [self containsWithLong:[((id<OrgJodaTimeReadableInstant>) nil_chk(instant)) getMillis]];
}

- (jboolean)containsWithOrgJodaTimeReadableInterval:(id<OrgJodaTimeReadableInterval>)interval {
  if (interval == nil) {
    return [self containsNow];
  }
  jlong otherStart = [((id<OrgJodaTimeReadableInterval>) nil_chk(interval)) getStartMillis];
  jlong otherEnd = [interval getEndMillis];
  jlong thisStart = [self getStartMillis];
  jlong thisEnd = [self getEndMillis];
  return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd);
}

- (jboolean)overlapsWithOrgJodaTimeReadableInterval:(id<OrgJodaTimeReadableInterval>)interval {
  jlong thisStart = [self getStartMillis];
  jlong thisEnd = [self getEndMillis];
  if (interval == nil) {
    jlong now = OrgJodaTimeDateTimeUtils_currentTimeMillis();
    return (thisStart < now && now < thisEnd);
  }
  else {
    jlong otherStart = [interval getStartMillis];
    jlong otherEnd = [interval getEndMillis];
    return (thisStart < otherEnd && otherStart < thisEnd);
  }
}

- (jboolean)isEqualWithOrgJodaTimeReadableInterval:(id<OrgJodaTimeReadableInterval>)other {
  return [self getStartMillis] == [((id<OrgJodaTimeReadableInterval>) nil_chk(other)) getStartMillis] && [self getEndMillis] == [other getEndMillis];
}

- (jboolean)isBeforeWithLong:(jlong)millisInstant {
  return ([self getEndMillis] <= millisInstant);
}

- (jboolean)isBeforeNow {
  return [self isBeforeWithLong:OrgJodaTimeDateTimeUtils_currentTimeMillis()];
}

- (jboolean)isBeforeWithOrgJodaTimeReadableInstant:(id<OrgJodaTimeReadableInstant>)instant {
  if (instant == nil) {
    return [self isBeforeNow];
  }
  return [self isBeforeWithLong:[((id<OrgJodaTimeReadableInstant>) nil_chk(instant)) getMillis]];
}

- (jboolean)isBeforeWithOrgJodaTimeReadableInterval:(id<OrgJodaTimeReadableInterval>)interval {
  if (interval == nil) {
    return [self isBeforeNow];
  }
  return [self isBeforeWithLong:[((id<OrgJodaTimeReadableInterval>) nil_chk(interval)) getStartMillis]];
}

- (jboolean)isAfterWithLong:(jlong)millisInstant {
  return ([self getStartMillis] > millisInstant);
}

- (jboolean)isAfterNow {
  return [self isAfterWithLong:OrgJodaTimeDateTimeUtils_currentTimeMillis()];
}

- (jboolean)isAfterWithOrgJodaTimeReadableInstant:(id<OrgJodaTimeReadableInstant>)instant {
  if (instant == nil) {
    return [self isAfterNow];
  }
  return [self isAfterWithLong:[((id<OrgJodaTimeReadableInstant>) nil_chk(instant)) getMillis]];
}

- (jboolean)isAfterWithOrgJodaTimeReadableInterval:(id<OrgJodaTimeReadableInterval>)interval {
  jlong endMillis;
  if (interval == nil) {
    endMillis = OrgJodaTimeDateTimeUtils_currentTimeMillis();
  }
  else {
    endMillis = [interval getEndMillis];
  }
  return ([self getStartMillis] >= endMillis);
}

- (OrgJodaTimeInterval *)toInterval {
  return [[[OrgJodaTimeInterval alloc] initWithLong:[self getStartMillis] withLong:[self getEndMillis] withOrgJodaTimeChronology:[self getChronology]] autorelease];
}

- (OrgJodaTimeMutableInterval *)toMutableInterval {
  return [[[OrgJodaTimeMutableInterval alloc] initWithLong:[self getStartMillis] withLong:[self getEndMillis] withOrgJodaTimeChronology:[self getChronology]] autorelease];
}

- (jlong)toDurationMillis {
  return OrgJodaTimeFieldFieldUtils_safeAddWithLong_withLong_([self getEndMillis], -[self getStartMillis]);
}

- (OrgJodaTimeDuration *)toDuration {
  jlong durMillis = [self toDurationMillis];
  if (durMillis == 0) {
    return OrgJodaTimeDuration_get_ZERO_();
  }
  else {
    return [[[OrgJodaTimeDuration alloc] initWithLong:durMillis] autorelease];
  }
}

- (OrgJodaTimePeriod *)toPeriod {
  return [[[OrgJodaTimePeriod alloc] initWithLong:[self getStartMillis] withLong:[self getEndMillis] withOrgJodaTimeChronology:[self getChronology]] autorelease];
}

- (OrgJodaTimePeriod *)toPeriodWithOrgJodaTimePeriodType:(OrgJodaTimePeriodType *)type {
  return [[[OrgJodaTimePeriod alloc] initWithLong:[self getStartMillis] withLong:[self getEndMillis] withOrgJodaTimePeriodType:type withOrgJodaTimeChronology:[self getChronology]] autorelease];
}

- (jboolean)isEqual:(id)readableInterval {
  if (self == readableInterval) {
    return YES;
  }
  if ([readableInterval conformsToProtocol: @protocol(OrgJodaTimeReadableInterval)] == NO) {
    return NO;
  }
  id<OrgJodaTimeReadableInterval> other = (id<OrgJodaTimeReadableInterval>) check_protocol_cast(readableInterval, @protocol(OrgJodaTimeReadableInterval));
  return [self getStartMillis] == [((id<OrgJodaTimeReadableInterval>) nil_chk(other)) getStartMillis] && [self getEndMillis] == [other getEndMillis] && OrgJodaTimeFieldFieldUtils_equalsWithId_withId_([self getChronology], [other getChronology]);
}

- (NSUInteger)hash {
  jlong start = [self getStartMillis];
  jlong end = [self getEndMillis];
  jint result = 97;
  result = 31 * result + ((jint) (start ^ (URShift64(start, 32))));
  result = 31 * result + ((jint) (end ^ (URShift64(end, 32))));
  result = 31 * result + ((jint) [((OrgJodaTimeChronology *) nil_chk([self getChronology])) hash]);
  return result;
}

- (NSString *)description {
  OrgJodaTimeFormatDateTimeFormatter *printer = OrgJodaTimeFormatISODateTimeFormat_dateTime();
  printer = [((OrgJodaTimeFormatDateTimeFormatter *) nil_chk(printer)) withChronologyWithOrgJodaTimeChronology:[self getChronology]];
  JavaLangStringBuffer *buf = [[[JavaLangStringBuffer alloc] initWithInt:48] autorelease];
  [((OrgJodaTimeFormatDateTimeFormatter *) nil_chk(printer)) printToWithJavaLangStringBuffer:buf withLong:[self getStartMillis]];
  [buf appendWithChar:'/'];
  [printer printToWithJavaLangStringBuffer:buf withLong:[self getEndMillis]];
  return [buf description];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "AbstractInterval", NULL, 0x4, NULL },
    { "checkIntervalWithLong:withLong:", "checkInterval", "V", 0x4, NULL },
    { "getStart", NULL, "Lorg.joda.time.DateTime;", 0x1, NULL },
    { "getEnd", NULL, "Lorg.joda.time.DateTime;", 0x1, NULL },
    { "containsWithLong:", "contains", "Z", 0x1, NULL },
    { "containsNow", NULL, "Z", 0x1, NULL },
    { "containsWithOrgJodaTimeReadableInstant:", "contains", "Z", 0x1, NULL },
    { "containsWithOrgJodaTimeReadableInterval:", "contains", "Z", 0x1, NULL },
    { "overlapsWithOrgJodaTimeReadableInterval:", "overlaps", "Z", 0x1, NULL },
    { "isEqualWithOrgJodaTimeReadableInterval:", "isEqual", "Z", 0x1, NULL },
    { "isBeforeWithLong:", "isBefore", "Z", 0x1, NULL },
    { "isBeforeNow", NULL, "Z", 0x1, NULL },
    { "isBeforeWithOrgJodaTimeReadableInstant:", "isBefore", "Z", 0x1, NULL },
    { "isBeforeWithOrgJodaTimeReadableInterval:", "isBefore", "Z", 0x1, NULL },
    { "isAfterWithLong:", "isAfter", "Z", 0x1, NULL },
    { "isAfterNow", NULL, "Z", 0x1, NULL },
    { "isAfterWithOrgJodaTimeReadableInstant:", "isAfter", "Z", 0x1, NULL },
    { "isAfterWithOrgJodaTimeReadableInterval:", "isAfter", "Z", 0x1, NULL },
    { "toInterval", NULL, "Lorg.joda.time.Interval;", 0x1, NULL },
    { "toMutableInterval", NULL, "Lorg.joda.time.MutableInterval;", 0x1, NULL },
    { "toDurationMillis", NULL, "J", 0x1, NULL },
    { "toDuration", NULL, "Lorg.joda.time.Duration;", 0x1, NULL },
    { "toPeriod", NULL, "Lorg.joda.time.Period;", 0x1, NULL },
    { "toPeriodWithOrgJodaTimePeriodType:", "toPeriod", "Lorg.joda.time.Period;", 0x1, NULL },
    { "isEqual:", "equals", "Z", 0x1, NULL },
    { "hash", "hashCode", "I", 0x1, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcClassInfo _OrgJodaTimeBaseAbstractInterval = { "AbstractInterval", "org.joda.time.base", NULL, 0x401, 27, methods, 0, NULL, 0, NULL};
  return &_OrgJodaTimeBaseAbstractInterval;
}

@end
