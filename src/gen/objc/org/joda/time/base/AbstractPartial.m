//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Mike/Projects/joda-time/src/main/java/org/joda/time/base/AbstractPartial.java
//

#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/ClassCastException.h"
#include "java/lang/IllegalArgumentException.h"
#include "org/joda/time/Chronology.h"
#include "org/joda/time/DateTime.h"
#include "org/joda/time/DateTimeField.h"
#include "org/joda/time/DateTimeFieldType.h"
#include "org/joda/time/DateTimeUtils.h"
#include "org/joda/time/DurationFieldType.h"
#include "org/joda/time/ReadableInstant.h"
#include "org/joda/time/ReadablePartial.h"
#include "org/joda/time/base/AbstractPartial.h"
#include "org/joda/time/field/FieldUtils.h"
#include "org/joda/time/format/DateTimeFormatter.h"

#pragma clang diagnostic ignored "-Wprotocol"

@implementation OrgJodaTimeBaseAbstractPartial

- (instancetype)init {
  return [super init];
}

- (OrgJodaTimeDateTimeField *)getFieldWithInt:(jint)index
                    withOrgJodaTimeChronology:(OrgJodaTimeChronology *)chrono {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (OrgJodaTimeDateTimeFieldType *)getFieldTypeWithInt:(jint)index {
  return [((OrgJodaTimeDateTimeField *) nil_chk([self getFieldWithInt:index withOrgJodaTimeChronology:[self getChronology]])) getType];
}

- (IOSObjectArray *)getFieldTypes {
  IOSObjectArray *result = [IOSObjectArray arrayWithLength:[self size] type:OrgJodaTimeDateTimeFieldType_class_()];
  for (jint i = 0; i < result->size_; i++) {
    IOSObjectArray_Set(result, i, [self getFieldTypeWithInt:i]);
  }
  return result;
}

- (OrgJodaTimeDateTimeField *)getFieldWithInt:(jint)index {
  return [self getFieldWithInt:index withOrgJodaTimeChronology:[self getChronology]];
}

- (IOSObjectArray *)getFields {
  IOSObjectArray *result = [IOSObjectArray arrayWithLength:[self size] type:OrgJodaTimeDateTimeField_class_()];
  for (jint i = 0; i < result->size_; i++) {
    IOSObjectArray_Set(result, i, [self getFieldWithInt:i]);
  }
  return result;
}

- (IOSIntArray *)getValues {
  IOSIntArray *result = [IOSIntArray arrayWithLength:[self size]];
  for (jint i = 0; i < result->size_; i++) {
    *IOSIntArray_GetRef(result, i) = [self getValueWithInt:i];
  }
  return result;
}

- (jint)getWithOrgJodaTimeDateTimeFieldType:(OrgJodaTimeDateTimeFieldType *)type {
  return [self getValueWithInt:[self indexOfSupportedWithOrgJodaTimeDateTimeFieldType:type]];
}

- (jboolean)isSupportedWithOrgJodaTimeDateTimeFieldType:(OrgJodaTimeDateTimeFieldType *)type {
  return ([self indexOfWithOrgJodaTimeDateTimeFieldType:type] != -1);
}

- (jint)indexOfWithOrgJodaTimeDateTimeFieldType:(OrgJodaTimeDateTimeFieldType *)type {
  for (jint i = 0, isize = [self size]; i < isize; i++) {
    if ([self getFieldTypeWithInt:i] == type) {
      return i;
    }
  }
  return -1;
}

- (jint)indexOfSupportedWithOrgJodaTimeDateTimeFieldType:(OrgJodaTimeDateTimeFieldType *)type {
  jint index = [self indexOfWithOrgJodaTimeDateTimeFieldType:type];
  if (index == -1) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$@$", @"Field '", type, @"' is not supported")] autorelease];
  }
  return index;
}

- (jint)indexOfWithOrgJodaTimeDurationFieldType:(OrgJodaTimeDurationFieldType *)type {
  for (jint i = 0, isize = [self size]; i < isize; i++) {
    if ([((OrgJodaTimeDateTimeFieldType *) nil_chk([self getFieldTypeWithInt:i])) getDurationType] == type) {
      return i;
    }
  }
  return -1;
}

- (jint)indexOfSupportedWithOrgJodaTimeDurationFieldType:(OrgJodaTimeDurationFieldType *)type {
  jint index = [self indexOfWithOrgJodaTimeDurationFieldType:type];
  if (index == -1) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$@$", @"Field '", type, @"' is not supported")] autorelease];
  }
  return index;
}

- (OrgJodaTimeDateTime *)toDateTimeWithOrgJodaTimeReadableInstant:(id<OrgJodaTimeReadableInstant>)baseInstant {
  OrgJodaTimeChronology *chrono = OrgJodaTimeDateTimeUtils_getInstantChronologyWithOrgJodaTimeReadableInstant_(baseInstant);
  jlong instantMillis = OrgJodaTimeDateTimeUtils_getInstantMillisWithOrgJodaTimeReadableInstant_(baseInstant);
  jlong resolved = [((OrgJodaTimeChronology *) nil_chk(chrono)) setWithOrgJodaTimeReadablePartial:self withLong:instantMillis];
  return [[[OrgJodaTimeDateTime alloc] initWithLong:resolved withOrgJodaTimeChronology:chrono] autorelease];
}

- (jboolean)isEqual:(id)partial {
  if (self == partial) {
    return YES;
  }
  if ([OrgJodaTimeReadablePartial_class_() isInstance:partial] == NO) {
    return NO;
  }
  id<OrgJodaTimeReadablePartial> other = (id<OrgJodaTimeReadablePartial>) check_protocol_cast(partial, @protocol(OrgJodaTimeReadablePartial));
  if ([self size] != [((id<OrgJodaTimeReadablePartial>) nil_chk(other)) size]) {
    return NO;
  }
  for (jint i = 0, isize = [self size]; i < isize; i++) {
    if ([self getValueWithInt:i] != [other getValueWithInt:i] || [self getFieldTypeWithInt:i] != [other getFieldTypeWithInt:i]) {
      return NO;
    }
  }
  return OrgJodaTimeFieldFieldUtils_equalsWithId_withId_([self getChronology], [other getChronology]);
}

- (NSUInteger)hash {
  jint total = 157;
  for (jint i = 0, isize = [self size]; i < isize; i++) {
    total = 23 * total + [self getValueWithInt:i];
    total = 23 * total + ((jint) [((OrgJodaTimeDateTimeFieldType *) nil_chk([self getFieldTypeWithInt:i])) hash]);
  }
  total += ((jint) [((OrgJodaTimeChronology *) nil_chk([self getChronology])) hash]);
  return total;
}

- (jint)compareToWithId:(id<OrgJodaTimeReadablePartial>)other {
  check_protocol_cast(other, @protocol(OrgJodaTimeReadablePartial));
  if (self == other) {
    return 0;
  }
  if ([self size] != [((id<OrgJodaTimeReadablePartial>) nil_chk(other)) size]) {
    @throw [[[JavaLangClassCastException alloc] initWithNSString:@"ReadablePartial objects must have matching field types"] autorelease];
  }
  for (jint i = 0, isize = [self size]; i < isize; i++) {
    if ([self getFieldTypeWithInt:i] != [other getFieldTypeWithInt:i]) {
      @throw [[[JavaLangClassCastException alloc] initWithNSString:@"ReadablePartial objects must have matching field types"] autorelease];
    }
  }
  for (jint i = 0, isize = [self size]; i < isize; i++) {
    if ([self getValueWithInt:i] > [other getValueWithInt:i]) {
      return 1;
    }
    if ([self getValueWithInt:i] < [other getValueWithInt:i]) {
      return -1;
    }
  }
  return 0;
}

- (jboolean)isAfterWithOrgJodaTimeReadablePartial:(id<OrgJodaTimeReadablePartial>)partial {
  if (partial == nil) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Partial cannot be null"] autorelease];
  }
  return [self compareToWithId:partial] > 0;
}

- (jboolean)isBeforeWithOrgJodaTimeReadablePartial:(id<OrgJodaTimeReadablePartial>)partial {
  if (partial == nil) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Partial cannot be null"] autorelease];
  }
  return [self compareToWithId:partial] < 0;
}

- (jboolean)isEqualWithOrgJodaTimeReadablePartial:(id<OrgJodaTimeReadablePartial>)partial {
  if (partial == nil) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Partial cannot be null"] autorelease];
  }
  return [self compareToWithId:partial] == 0;
}

- (NSString *)toStringWithOrgJodaTimeFormatDateTimeFormatter:(OrgJodaTimeFormatDateTimeFormatter *)formatter {
  if (formatter == nil) {
    return [self description];
  }
  return [((OrgJodaTimeFormatDateTimeFormatter *) nil_chk(formatter)) printWithOrgJodaTimeReadablePartial:self];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "AbstractPartial", NULL, 0x4, NULL },
    { "getFieldWithInt:withOrgJodaTimeChronology:", "getField", "Lorg.joda.time.DateTimeField;", 0x404, NULL },
    { "getFieldTypeWithInt:", "getFieldType", "Lorg.joda.time.DateTimeFieldType;", 0x1, NULL },
    { "getFieldTypes", NULL, "[Lorg.joda.time.DateTimeFieldType;", 0x1, NULL },
    { "getFieldWithInt:", "getField", "Lorg.joda.time.DateTimeField;", 0x1, NULL },
    { "getFields", NULL, "[Lorg.joda.time.DateTimeField;", 0x1, NULL },
    { "getValues", NULL, "[I", 0x1, NULL },
    { "getWithOrgJodaTimeDateTimeFieldType:", "get", "I", 0x1, NULL },
    { "isSupportedWithOrgJodaTimeDateTimeFieldType:", "isSupported", "Z", 0x1, NULL },
    { "indexOfWithOrgJodaTimeDateTimeFieldType:", "indexOf", "I", 0x1, NULL },
    { "indexOfSupportedWithOrgJodaTimeDateTimeFieldType:", "indexOfSupported", "I", 0x4, NULL },
    { "indexOfWithOrgJodaTimeDurationFieldType:", "indexOf", "I", 0x4, NULL },
    { "indexOfSupportedWithOrgJodaTimeDurationFieldType:", "indexOfSupported", "I", 0x4, NULL },
    { "toDateTimeWithOrgJodaTimeReadableInstant:", "toDateTime", "Lorg.joda.time.DateTime;", 0x1, NULL },
    { "isEqual:", "equals", "Z", 0x1, NULL },
    { "hash", "hashCode", "I", 0x1, NULL },
    { "compareToWithOrgJodaTimeReadablePartial:", "compareTo", "I", 0x1, NULL },
    { "isAfterWithOrgJodaTimeReadablePartial:", "isAfter", "Z", 0x1, NULL },
    { "isBeforeWithOrgJodaTimeReadablePartial:", "isBefore", "Z", 0x1, NULL },
    { "isEqualWithOrgJodaTimeReadablePartial:", "isEqual", "Z", 0x1, NULL },
    { "toStringWithOrgJodaTimeFormatDateTimeFormatter:", "toString", "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcClassInfo _OrgJodaTimeBaseAbstractPartial = { 1, "AbstractPartial", "org.joda.time.base", NULL, 0x401, 21, methods, 0, NULL, 0, NULL};
  return &_OrgJodaTimeBaseAbstractPartial;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgJodaTimeBaseAbstractPartial)
