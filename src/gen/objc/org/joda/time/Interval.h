//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/marcussmith/HambroPerks/hambroperks_org/joda-time/src/main/java/org/joda/time/Interval.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgJodaTimeInterval")
#ifdef RESTRICT_OrgJodaTimeInterval
#define INCLUDE_ALL_OrgJodaTimeInterval 0
#else
#define INCLUDE_ALL_OrgJodaTimeInterval 1
#endif
#undef RESTRICT_OrgJodaTimeInterval

#if !defined (OrgJodaTimeInterval_) && (INCLUDE_ALL_OrgJodaTimeInterval || defined(INCLUDE_OrgJodaTimeInterval))
#define OrgJodaTimeInterval_

#define RESTRICT_OrgJodaTimeBaseBaseInterval 1
#define INCLUDE_OrgJodaTimeBaseBaseInterval 1
#include "org/joda/time/base/BaseInterval.h"

#define RESTRICT_OrgJodaTimeReadableInterval 1
#define INCLUDE_OrgJodaTimeReadableInterval 1
#include "org/joda/time/ReadableInterval.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class OrgJodaTimeChronology;
@class OrgJodaTimeDateTimeZone;
@protocol OrgJodaTimeReadableDuration;
@protocol OrgJodaTimeReadableInstant;
@protocol OrgJodaTimeReadablePeriod;

/*!
 @brief Interval is the standard implementation of an immutable time interval.
 <p>
  A time interval represents a period of time between two instants.
  Intervals are inclusive of the start instant and exclusive of the end.
  The end instant is always greater than or equal to the start instant. 
 <p>
  Intervals have a fixed millisecond duration.
  This is the difference between the start and end instants.
  The duration is represented separately by <code>ReadableDuration</code>.
  As a result, intervals are not comparable.
  To compare the length of two intervals, you should compare their durations. 
 <p>
  An interval can also be converted to a <code>ReadablePeriod</code>.
  This represents the difference between the start and end points in terms of fields
  such as years and days. 
 <p>
  Interval is thread-safe and immutable.
 @author Brian S O'Neill
 @author Sean Geoghegan
 @author Stephen Colebourne
 @author Julen Parra
 @since 1.0
 */
@interface OrgJodaTimeInterval : OrgJodaTimeBaseBaseInterval < OrgJodaTimeReadableInterval, JavaIoSerializable >

#pragma mark Public

/*!
 @brief Constructs an interval from a start and end instant with the ISO
  default chronology in the default time zone.
 @param startInstant start of this interval, as milliseconds from 1970-01-01T00:00:00Z.
 @param endInstant end of this interval, as milliseconds from 1970-01-01T00:00:00Z.
 @throw IllegalArgumentExceptionif the end is before the start
 */
- (instancetype)initWithLong:(jlong)startInstant
                    withLong:(jlong)endInstant;

/*!
 @brief Constructs an interval from a start and end instant with the
  specified chronology.
 @param chronology the chronology to use, null is ISO default
 @param startInstant start of this interval, as milliseconds from 1970-01-01T00:00:00Z.
 @param endInstant end of this interval, as milliseconds from 1970-01-01T00:00:00Z.
 @throw IllegalArgumentExceptionif the end is before the start
 */
- (instancetype)initWithLong:(jlong)startInstant
                    withLong:(jlong)endInstant
   withOrgJodaTimeChronology:(OrgJodaTimeChronology *)chronology;

/*!
 @brief Constructs an interval from a start and end instant with the ISO
  default chronology in the specified time zone.
 @param startInstant start of this interval, as milliseconds from 1970-01-01T00:00:00Z.
 @param endInstant end of this interval, as milliseconds from 1970-01-01T00:00:00Z.
 @param zone the time zone to use, null means default zone
 @throw IllegalArgumentExceptionif the end is before the start
 @since 1.5
 */
- (instancetype)initWithLong:(jlong)startInstant
                    withLong:(jlong)endInstant
 withOrgJodaTimeDateTimeZone:(OrgJodaTimeDateTimeZone *)zone;

/*!
 @brief Constructs a time interval by converting or copying from another object.
 <p>
  The recognised object types are defined in 
 <code>ConverterManager</code> and
  include ReadableInterval and String.
  The String formats are described by <code>ISODateTimeFormat.dateTimeParser()</code>
  and <code>ISOPeriodFormat.standard()</code>, and may be 'datetime/datetime',
  'datetime/period' or 'period/datetime'.
 @param interval the time interval to copy
 @throw IllegalArgumentExceptionif the interval is invalid
 */
- (instancetype)initWithId:(id)interval;

/*!
 @brief Constructs a time interval by converting or copying from another object,
  overriding the chronology.
 <p>
  The recognised object types are defined in 
 <code>ConverterManager</code> and
  include ReadableInterval and String.
  The String formats are described by <code>ISODateTimeFormat.dateTimeParser()</code>
  and <code>ISOPeriodFormat.standard()</code>, and may be 'datetime/datetime',
  'datetime/period' or 'period/datetime'.
 @param interval the time interval to copy
 @param chronology the chronology to use, null means ISO default
 @throw IllegalArgumentExceptionif the interval is invalid
 */
- (instancetype)initWithId:(id)interval
 withOrgJodaTimeChronology:(OrgJodaTimeChronology *)chronology;

/*!
 @brief Constructs an interval from a millisecond duration and an end instant.
 @param duration the duration of this interval, null means zero length
 @param end end of this interval, null means now
 @throw IllegalArgumentExceptionif the end is before the start
 @throw ArithmeticExceptionif the start instant exceeds the capacity of a long
 */
- (instancetype)initWithOrgJodaTimeReadableDuration:(id<OrgJodaTimeReadableDuration>)duration
                     withOrgJodaTimeReadableInstant:(id<OrgJodaTimeReadableInstant>)end;

/*!
 @brief Constructs an interval from a start instant and a duration.
 @param start start of this interval, null means now
 @param duration the duration of this interval, null means zero length
 @throw IllegalArgumentExceptionif the end is before the start
 @throw ArithmeticExceptionif the end instant exceeds the capacity of a long
 */
- (instancetype)initWithOrgJodaTimeReadableInstant:(id<OrgJodaTimeReadableInstant>)start
                   withOrgJodaTimeReadableDuration:(id<OrgJodaTimeReadableDuration>)duration;

/*!
 @brief Constructs an interval from a start and end instant.
 <p>
  The chronology used is that of the start instant.
 @param start start of this interval, null means now
 @param end end of this interval, null means now
 @throw IllegalArgumentExceptionif the end is before the start
 */
- (instancetype)initWithOrgJodaTimeReadableInstant:(id<OrgJodaTimeReadableInstant>)start
                    withOrgJodaTimeReadableInstant:(id<OrgJodaTimeReadableInstant>)end;

/*!
 @brief Constructs an interval from a start instant and a time period.
 <p>
  When forming the interval, the chronology from the instant is used
  if present, otherwise the chronology of the period is used.
 @param start start of this interval, null means now
 @param period the period of this interval, null means zero length
 @throw IllegalArgumentExceptionif the end is before the start
 @throw ArithmeticExceptionif the end instant exceeds the capacity of a long
 */
- (instancetype)initWithOrgJodaTimeReadableInstant:(id<OrgJodaTimeReadableInstant>)start
                     withOrgJodaTimeReadablePeriod:(id<OrgJodaTimeReadablePeriod>)period;

/*!
 @brief Constructs an interval from a time period and an end instant.
 <p>
  When forming the interval, the chronology from the instant is used
  if present, otherwise the chronology of the period is used.
 @param period the period of this interval, null means zero length
 @param end end of this interval, null means now
 @throw IllegalArgumentExceptionif the end is before the start
 @throw ArithmeticExceptionif the start instant exceeds the capacity of a long
 */
- (instancetype)initWithOrgJodaTimeReadablePeriod:(id<OrgJodaTimeReadablePeriod>)period
                   withOrgJodaTimeReadableInstant:(id<OrgJodaTimeReadableInstant>)end;

/*!
 @brief Does this interval abut with the interval specified.
 <p>
  Intervals are inclusive of the start instant and exclusive of the end.
  An interval abuts if it starts immediately after, or ends immediately
  before this interval without overlap.
  A zero duration interval abuts with itself. 
 <p>
  When two intervals are compared the result is one of three states:
  (a) they abut, (b) there is a gap between them, (c) they overlap.
  The abuts state takes precedence over the other two, thus a zero duration
  interval at the start of a larger interval abuts and does not overlap. 
 <p>
  For example: 
 @code

  [09:00 to 10:00) abuts [08:00 to 08:30)  = false (completely before)
  [09:00 to 10:00) abuts [08:00 to 09:00)  = true
  [09:00 to 10:00) abuts [08:00 to 09:01)  = false (overlaps) 
  [09:00 to 10:00) abuts [09:00 to 09:00)  = true
  [09:00 to 10:00) abuts [09:00 to 09:01)  = false (overlaps) 
  [09:00 to 10:00) abuts [10:00 to 10:00)  = true
  [09:00 to 10:00) abuts [10:00 to 10:30)  = true 
  [09:00 to 10:00) abuts [10:30 to 11:00)  = false (completely after) 
  [14:00 to 14:00) abuts [14:00 to 14:00)  = true
  [14:00 to 14:00) abuts [14:00 to 15:00)  = true
  [14:00 to 14:00) abuts [13:00 to 14:00)  = true 
  
@endcode
 @param interval the interval to examine, null means now
 @return true if the interval abuts
 @since 1.1
 */
- (jboolean)abutsWithOrgJodaTimeReadableInterval:(id<OrgJodaTimeReadableInterval>)interval;

/*!
 @brief Gets the gap between this interval and another interval.
 The other interval can be either before or after this interval. 
 <p>
  Intervals are inclusive of the start instant and exclusive of the end.
  An interval has a gap to another interval if there is a non-zero
  duration between them. This method returns the amount of the gap only
  if the intervals do actually have a gap between them.
  If the intervals overlap or abut, then null is returned. 
 <p>
  When two intervals are compared the result is one of three states:
  (a) they abut, (b) there is a gap between them, (c) they overlap.
  The abuts state takes precedence over the other two, thus a zero duration
  interval at the start of a larger interval abuts and does not overlap. 
 <p>
  The chronology of the returned interval is the same as that of
  this interval (the chronology of the interval parameter is not used).
  Note that the use of the chronology was only correctly implemented
  in version 1.3.
 @param interval the interval to examine, null means now
 @return the gap interval, null if no gap
 @since 1.1
 */
- (OrgJodaTimeInterval *)gapWithOrgJodaTimeReadableInterval:(id<OrgJodaTimeReadableInterval>)interval;

/*!
 @brief Gets the overlap between this interval and another interval.
 <p>
  Intervals are inclusive of the start instant and exclusive of the end.
  An interval overlaps another if it shares some common part of the
  datetime continuum. This method returns the amount of the overlap,
  only if the intervals actually do overlap.
  If the intervals do not overlap, then null is returned. 
 <p>
  When two intervals are compared the result is one of three states:
  (a) they abut, (b) there is a gap between them, (c) they overlap.
  The abuts state takes precedence over the other two, thus a zero duration
  interval at the start of a larger interval abuts and does not overlap. 
 <p>
  The chronology of the returned interval is the same as that of
  this interval (the chronology of the interval parameter is not used).
  Note that the use of the chronology was only correctly implemented
  in version 1.3.
 @param interval the interval to examine, null means now
 @return the overlap interval, null if no overlap
 @since 1.1
 */
- (OrgJodaTimeInterval *)overlapWithOrgJodaTimeReadableInterval:(id<OrgJodaTimeReadableInterval>)interval;

/*!
 @brief Parses a <code>Interval</code> from the specified string.
 <p>
  The String formats are described by <code>ISODateTimeFormat.dateTimeParser()</code>
  and <code>ISOPeriodFormat.standard()</code>, and may be 'datetime/datetime',
  'datetime/period' or 'period/datetime'.
 @param str the string to parse, not null
 @since 2.0
 */
+ (OrgJodaTimeInterval *)parseWithNSString:(NSString *)str;

/*!
 @brief Get this interval as an immutable <code>Interval</code> object
  by returning <code>this</code>.
 @return <code>this</code>
 */
- (OrgJodaTimeInterval *)toInterval;

/*!
 @brief Creates a new interval with the same start and end, but a different chronology.
 @param chronology the chronology to use, null means ISO default
 @return an interval with a different chronology
 */
- (OrgJodaTimeInterval *)withChronologyWithOrgJodaTimeChronology:(OrgJodaTimeChronology *)chronology;

/*!
 @brief Creates a new interval with the specified duration after the start instant.
 @param duration the duration to add to the start to get the new end instant, null means zero
 @return an interval with the start from this interval and a calculated end
 @throw IllegalArgumentExceptionif the duration is negative
 */
- (OrgJodaTimeInterval *)withDurationAfterStartWithOrgJodaTimeReadableDuration:(id<OrgJodaTimeReadableDuration>)duration;

/*!
 @brief Creates a new interval with the specified duration before the end instant.
 @param duration the duration to subtract from the end to get the new start instant, null means zero
 @return an interval with the end from this interval and a calculated start
 @throw IllegalArgumentExceptionif the duration is negative
 */
- (OrgJodaTimeInterval *)withDurationBeforeEndWithOrgJodaTimeReadableDuration:(id<OrgJodaTimeReadableDuration>)duration;

/*!
 @brief Creates a new interval with the specified end instant.
 @param end the end instant for the new interval, null means now
 @return an interval with the start from this interval and the specified end
 @throw IllegalArgumentExceptionif the resulting interval has end before start
 */
- (OrgJodaTimeInterval *)withEndWithOrgJodaTimeReadableInstant:(id<OrgJodaTimeReadableInstant>)end;

/*!
 @brief Creates a new interval with the specified start millisecond instant.
 @param endInstant the end instant for the new interval
 @return an interval with the start from this interval and the specified end
 @throw IllegalArgumentExceptionif the resulting interval has end before start
 */
- (OrgJodaTimeInterval *)withEndMillisWithLong:(jlong)endInstant;

/*!
 @brief Creates a new interval with the specified period after the start instant.
 @param period the period to add to the start to get the new end instant, null means zero
 @return an interval with the start from this interval and a calculated end
 @throw IllegalArgumentExceptionif the period is negative
 */
- (OrgJodaTimeInterval *)withPeriodAfterStartWithOrgJodaTimeReadablePeriod:(id<OrgJodaTimeReadablePeriod>)period;

/*!
 @brief Creates a new interval with the specified period before the end instant.
 @param period the period to subtract from the end to get the new start instant, null means zero
 @return an interval with the end from this interval and a calculated start
 @throw IllegalArgumentExceptionif the period is negative
 */
- (OrgJodaTimeInterval *)withPeriodBeforeEndWithOrgJodaTimeReadablePeriod:(id<OrgJodaTimeReadablePeriod>)period;

/*!
 @brief Creates a new interval with the specified start instant.
 @param start the start instant for the new interval, null means now
 @return an interval with the end from this interval and the specified start
 @throw IllegalArgumentExceptionif the resulting interval has end before start
 */
- (OrgJodaTimeInterval *)withStartWithOrgJodaTimeReadableInstant:(id<OrgJodaTimeReadableInstant>)start;

/*!
 @brief Creates a new interval with the specified start millisecond instant.
 @param startInstant the start instant for the new interval
 @return an interval with the end from this interval and the specified start
 @throw IllegalArgumentExceptionif the resulting interval has end before start
 */
- (OrgJodaTimeInterval *)withStartMillisWithLong:(jlong)startInstant;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgJodaTimeInterval)

FOUNDATION_EXPORT OrgJodaTimeInterval *OrgJodaTimeInterval_parseWithNSString_(NSString *str);

FOUNDATION_EXPORT void OrgJodaTimeInterval_initWithLong_withLong_(OrgJodaTimeInterval *self, jlong startInstant, jlong endInstant);

FOUNDATION_EXPORT OrgJodaTimeInterval *new_OrgJodaTimeInterval_initWithLong_withLong_(jlong startInstant, jlong endInstant) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgJodaTimeInterval *create_OrgJodaTimeInterval_initWithLong_withLong_(jlong startInstant, jlong endInstant);

FOUNDATION_EXPORT void OrgJodaTimeInterval_initWithLong_withLong_withOrgJodaTimeDateTimeZone_(OrgJodaTimeInterval *self, jlong startInstant, jlong endInstant, OrgJodaTimeDateTimeZone *zone);

FOUNDATION_EXPORT OrgJodaTimeInterval *new_OrgJodaTimeInterval_initWithLong_withLong_withOrgJodaTimeDateTimeZone_(jlong startInstant, jlong endInstant, OrgJodaTimeDateTimeZone *zone) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgJodaTimeInterval *create_OrgJodaTimeInterval_initWithLong_withLong_withOrgJodaTimeDateTimeZone_(jlong startInstant, jlong endInstant, OrgJodaTimeDateTimeZone *zone);

FOUNDATION_EXPORT void OrgJodaTimeInterval_initWithLong_withLong_withOrgJodaTimeChronology_(OrgJodaTimeInterval *self, jlong startInstant, jlong endInstant, OrgJodaTimeChronology *chronology);

FOUNDATION_EXPORT OrgJodaTimeInterval *new_OrgJodaTimeInterval_initWithLong_withLong_withOrgJodaTimeChronology_(jlong startInstant, jlong endInstant, OrgJodaTimeChronology *chronology) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgJodaTimeInterval *create_OrgJodaTimeInterval_initWithLong_withLong_withOrgJodaTimeChronology_(jlong startInstant, jlong endInstant, OrgJodaTimeChronology *chronology);

FOUNDATION_EXPORT void OrgJodaTimeInterval_initWithOrgJodaTimeReadableInstant_withOrgJodaTimeReadableInstant_(OrgJodaTimeInterval *self, id<OrgJodaTimeReadableInstant> start, id<OrgJodaTimeReadableInstant> end);

FOUNDATION_EXPORT OrgJodaTimeInterval *new_OrgJodaTimeInterval_initWithOrgJodaTimeReadableInstant_withOrgJodaTimeReadableInstant_(id<OrgJodaTimeReadableInstant> start, id<OrgJodaTimeReadableInstant> end) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgJodaTimeInterval *create_OrgJodaTimeInterval_initWithOrgJodaTimeReadableInstant_withOrgJodaTimeReadableInstant_(id<OrgJodaTimeReadableInstant> start, id<OrgJodaTimeReadableInstant> end);

FOUNDATION_EXPORT void OrgJodaTimeInterval_initWithOrgJodaTimeReadableInstant_withOrgJodaTimeReadableDuration_(OrgJodaTimeInterval *self, id<OrgJodaTimeReadableInstant> start, id<OrgJodaTimeReadableDuration> duration);

FOUNDATION_EXPORT OrgJodaTimeInterval *new_OrgJodaTimeInterval_initWithOrgJodaTimeReadableInstant_withOrgJodaTimeReadableDuration_(id<OrgJodaTimeReadableInstant> start, id<OrgJodaTimeReadableDuration> duration) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgJodaTimeInterval *create_OrgJodaTimeInterval_initWithOrgJodaTimeReadableInstant_withOrgJodaTimeReadableDuration_(id<OrgJodaTimeReadableInstant> start, id<OrgJodaTimeReadableDuration> duration);

FOUNDATION_EXPORT void OrgJodaTimeInterval_initWithOrgJodaTimeReadableDuration_withOrgJodaTimeReadableInstant_(OrgJodaTimeInterval *self, id<OrgJodaTimeReadableDuration> duration, id<OrgJodaTimeReadableInstant> end);

FOUNDATION_EXPORT OrgJodaTimeInterval *new_OrgJodaTimeInterval_initWithOrgJodaTimeReadableDuration_withOrgJodaTimeReadableInstant_(id<OrgJodaTimeReadableDuration> duration, id<OrgJodaTimeReadableInstant> end) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgJodaTimeInterval *create_OrgJodaTimeInterval_initWithOrgJodaTimeReadableDuration_withOrgJodaTimeReadableInstant_(id<OrgJodaTimeReadableDuration> duration, id<OrgJodaTimeReadableInstant> end);

FOUNDATION_EXPORT void OrgJodaTimeInterval_initWithOrgJodaTimeReadableInstant_withOrgJodaTimeReadablePeriod_(OrgJodaTimeInterval *self, id<OrgJodaTimeReadableInstant> start, id<OrgJodaTimeReadablePeriod> period);

FOUNDATION_EXPORT OrgJodaTimeInterval *new_OrgJodaTimeInterval_initWithOrgJodaTimeReadableInstant_withOrgJodaTimeReadablePeriod_(id<OrgJodaTimeReadableInstant> start, id<OrgJodaTimeReadablePeriod> period) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgJodaTimeInterval *create_OrgJodaTimeInterval_initWithOrgJodaTimeReadableInstant_withOrgJodaTimeReadablePeriod_(id<OrgJodaTimeReadableInstant> start, id<OrgJodaTimeReadablePeriod> period);

FOUNDATION_EXPORT void OrgJodaTimeInterval_initWithOrgJodaTimeReadablePeriod_withOrgJodaTimeReadableInstant_(OrgJodaTimeInterval *self, id<OrgJodaTimeReadablePeriod> period, id<OrgJodaTimeReadableInstant> end);

FOUNDATION_EXPORT OrgJodaTimeInterval *new_OrgJodaTimeInterval_initWithOrgJodaTimeReadablePeriod_withOrgJodaTimeReadableInstant_(id<OrgJodaTimeReadablePeriod> period, id<OrgJodaTimeReadableInstant> end) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgJodaTimeInterval *create_OrgJodaTimeInterval_initWithOrgJodaTimeReadablePeriod_withOrgJodaTimeReadableInstant_(id<OrgJodaTimeReadablePeriod> period, id<OrgJodaTimeReadableInstant> end);

FOUNDATION_EXPORT void OrgJodaTimeInterval_initWithId_(OrgJodaTimeInterval *self, id interval);

FOUNDATION_EXPORT OrgJodaTimeInterval *new_OrgJodaTimeInterval_initWithId_(id interval) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgJodaTimeInterval *create_OrgJodaTimeInterval_initWithId_(id interval);

FOUNDATION_EXPORT void OrgJodaTimeInterval_initWithId_withOrgJodaTimeChronology_(OrgJodaTimeInterval *self, id interval, OrgJodaTimeChronology *chronology);

FOUNDATION_EXPORT OrgJodaTimeInterval *new_OrgJodaTimeInterval_initWithId_withOrgJodaTimeChronology_(id interval, OrgJodaTimeChronology *chronology) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgJodaTimeInterval *create_OrgJodaTimeInterval_initWithId_withOrgJodaTimeChronology_(id interval, OrgJodaTimeChronology *chronology);

J2OBJC_TYPE_LITERAL_HEADER(OrgJodaTimeInterval)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgJodaTimeInterval")
